(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{398:function(e,t,o){"use strict";o.r(t);var i=o(54),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"building-a-nuxt-js-blog-site-and-deploying-it-using-travis-ci"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#building-a-nuxt-js-blog-site-and-deploying-it-using-travis-ci"}},[e._v("#")]),e._v(" Building a Nuxt.js Blog Site and deploying it using Travis CI")]),e._v(" "),o("p",[o("strong",[e._v("Published:")]),e._v(" "),o("em",[e._v("09/18/2020")])]),e._v(" "),o("p",[e._v("This week I learned more about the core features of "),o("code",[e._v("Nuxt.js")]),e._v(" while I build a dynamically routed blog section on my personal website. I also took some time to setup a docker instance with a standard "),o("code",[e._v("Linux-Appache-MySQL-PhP")]),e._v(" ("),o("em",[e._v("LAMP")]),e._v(") Stack and manage the configuration and setup to deploy a containerized web-server. Finally, I've learned a new skill for "),o("code",[e._v("Continuous-Integration/Continuous-Deployment")]),e._v(" ("),o("em",[e._v("CI/CD")]),e._v(") using"),o("code",[e._v("Travis-CI")]),e._v(" to build my pipeline from development to deployment.")]),e._v(" "),o("hr"),e._v(" "),o("h2",{attrs:{id:"using-nuxt-js-vuex-to-dynamically-generate-and-route-blog-posts"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#using-nuxt-js-vuex-to-dynamically-generate-and-route-blog-posts"}},[e._v("#")]),e._v(" Using Nuxt.js & Vuex to Dynamically Generate and Route Blog posts")]),e._v(" "),o("p",[e._v("I spent a lot of time understanding what the key differences in "),o("code",[e._v("Nuxt.js")]),e._v(" and process flow compared to vanilla "),o("code",[e._v("Vue.js")]),e._v(" and how to statically generate a site using Nuxt.js uses a "),o("strong",[e._v("state-management")]),e._v(" library such as "),o("code",[e._v("VueX")]),e._v(". I dynamically loaded each "),o("strong",[e._v("blog sections")]),e._v(" & "),o("strong",[e._v("blogs")]),e._v(" dependent on how the folder structure was set up in the directory listing. With the help of Nuxt.js's "),o("code",[e._v("content module")]),e._v(", it supports "),o("strong",[e._v("Mark Down")]),e._v(" content creation through a "),o("em",[e._v("head-less CMS")]),e._v(" or "),o("strong",[e._v("Content Management System")]),e._v(" and supports browser integration that updates the blog's "),o("em",[e._v("Mark Down")]),e._v(" in "),o("strong",[e._v("real time")]),e._v(".")]),e._v(" "),o("p",[o("img",{attrs:{src:"/2020/nuxt-content-module.gif",alt:"blog file structure"}})]),e._v(" "),o("p",[e._v("Learn more on "),o("strong",[e._v("Nuxt.js")]),e._v(" & "),o("em",[e._v("State Management")]),e._v(": https://nuxtjs.org/guide/vuex-store/")]),e._v(" "),o("h2",{attrs:{id:"using-docker-to-spin-up-a-lampstack-web-server"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#using-docker-to-spin-up-a-lampstack-web-server"}},[e._v("#")]),e._v(" Using Docker to Spin up a LAMPstack Web-Server")]),e._v(" "),o("p",[e._v("Using "),o("code",[e._v("docker")]),e._v(", I was able to create a "),o("strong",[e._v("containerized environment")]),e._v(" to support/deploy a "),o("strong",[e._v("LAMP")]),e._v(" stack web-application. With just a few commands like "),o("code",[e._v("docker run -it ubuntu:latest")]),e._v(" to build an environment based off a pre-existing remote docker image hosted on "),o("code",[e._v("docker-hub")]),e._v(". I then interfaced with the container via CLI with the following command "),o("code",[e._v("docker exec -it HASH/Alias bash")]),e._v(" and was able to have the full experience similar to a Virtual Machine "),o("strong",[e._v("VM")]),e._v(".")]),e._v(" "),o("p",[o("img",{attrs:{src:"/2020/docker-container.png",alt:"docker engine"}})]),e._v(" "),o("p",[e._v("Find more on "),o("strong",[e._v("Docker")]),e._v(" in the following link: https://www.docker.com/")]),e._v(" "),o("h2",{attrs:{id:"building-a-ci-cd-pipeline-with-travis-ci"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#building-a-ci-cd-pipeline-with-travis-ci"}},[e._v("#")]),e._v(" Building a CI/CD Pipeline with Travis-CI")]),e._v(" "),o("p",[e._v("I create a whole development/deployment workflow for this website to implement "),o("strong",[e._v("CI/CD")]),e._v(" principles using "),o("code",[e._v("Travis-CI")]),e._v(". I created two repositories on "),o("strong",[e._v("GitHub")]),e._v(", one with my un-compiled code and another with "),o("em",[e._v("only")]),e._v(" compiled code available to my "),o("code",[e._v("GitHub Pages")]),e._v(" repo which hosts my personal website. I learned about how to set-up my "),o("em",[e._v("travis.yml")]),e._v(" configuration file to properly "),o("strong",[e._v("Test & Build")]),e._v(" my application pipeline. I was able to implement Travis-CI for free since I have a public repo and I know I most likely won't go over the 100 build limit in case I switch over to a private repo, for now I should recieve no cost for a service to run my pipeline. I had encountered a technical barrier of having to host the root compiled code on my personal websites on GitHub Pages since I needed a way to compile my compile my code while ensuring the proper directory structure is maintained on my second public repo for my compiled code base.")]),e._v(" "),o("p",[o("img",{attrs:{src:"/2020/travis-ci.gif",alt:"travis pipeline build status"}})]),e._v(" "),o("p",[e._v("Find more about CI pipelines from "),o("strong",[e._v("Travis-CI")]),e._v(" at the following link: https://travis-ci.org/")])])}),[],!1,null,null,null);t.default=n.exports}}]);